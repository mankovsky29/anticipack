@page "/edit-packing/{id}"
@using Anticipack.Packing
@using Anticipack.Services
@using Anticipack.Storage
@using System.Threading
@using System.Text.Json
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.JSInterop
@using Anticipack.Components.Shared.DialogComponent
@using Anticipack.Components.Shared.ToastComponent
@using Anticipack.Components.Shared.NavigationHeaderComponent
@using Anticipack.Resources.Localization
@inject NavigationManager Navigation
@inject IPackingRepository PackingRepository
@inject IJSRuntime JSRuntime
@inject IDialogService DialogService
@inject IToastService ToastService
@inject INavigationHeaderService NavigationHeaderService
@implements IDisposable
@inject IKeyboardService KeyboardService
@inject ILocalizationService LocalizationService
@inject MicrophonePermissionBridge PermissionBridge

<NavigationLock OnBeforeInternalNavigation="OnBeforeInternalNavigation" />

<div class="page-container with-fixed-navbar" @onclick="HandlePageClick">
<div class="activity-header" role="banner" aria-label="@AppResources.PackingActivity">
    <!-- Actions on second line -->
    <div class="header-actions">
        <div class="activity-actions activity-actions-left" role="group" aria-label="@AppResources.PackingDialogMenu">
            <!-- Primary action: Play button -->
            <button class="icon-btn play" @onclick="SwitchToPackingMode" @onclick:stopPropagation aria-label="@AppResources.StartPacking">
                <i class="fa fa-play" aria-hidden="true"></i>
            </button>

            <!-- Copy button -->
            <button class="icon-btn" @onclick="CopyPacking" @onclick:stopPropagation title="@AppResources.CopyTitle">
                <i class="fa fa-copy" aria-hidden="true"></i>
            </button>

            <!-- Add item button -->
            <button class="icon-btn" @onclick="ShowAddItemForm" @onclick:stopPropagation title="@AppResources.AddItem">
                <i class="fa fa-plus" aria-hidden="true"></i>
            </button>
        </div>

        <div class="activity-actions activity-actions-right" role="group">
            <!-- Delete activity button -->
            <button class="icon-btn delete-item" @onclick="PromptDeleteActivity" @onclick:stopPropagation title="@AppResources.DeleteActivity">
                <i class="fa fa-trash" aria-hidden="true"></i>
            </button>
        </div>
    </div>
</div>

<div class="activity-header" role="banner" aria-label="@AppResources.PackingActivity">
    <!-- Title on first line -->
    <div class="header-left-section">
        <input type="text"
                class="activity-name-input"
                @bind="_activityName"
                @bind:event="oninput"
                @onblur="SaveActivityNameAsync"
                placeholder="@AppResources.EnterActivityName" />
    </div>
</div>

    <main class="content-area">
        @if (_isLoading)
        {
            <div class="loading">
                <div class="loading-spinner"></div>
                <span>@AppResources.LoadingPacking</span>
            </div>
        }

        <div class="packing-list">
            @if (_isAddingItem)
            {
                <div class="add-item-form">
                    <div class="form-header-inline">
                        <h4>@AppResources.AddNewItems</h4>
                        <button class="close-form-btn" @onclick="CancelAdd" title="@AppResources.Cancel">
                            <i class="fa fa-times"></i>
                        </button>
                    </div>
                    
                    <div class="form-body">
                        <div class="form-section compact">
                            <label for="category-select" class="form-label-inline">
                                @AppResources.SelectCategory
                            </label>
                            <select id="category-select" 
                                    class="category-select" 
                                    @bind="_newCategory">
                                @foreach (var category in Enum.GetValues<PackingCategory>())
                                {
                                    <option value="@category.ToString()">@GetLocalizedCategoryName(category)</option>
                                }
                            </select>
                        </div>
                        
                        <div class="form-section compact">
                            <label for="bulk-textarea" class="form-label-inline">
                                <i class="fa fa-list-ul"></i>
                                @AppResources.EnterItemName
                            </label>
                            <div class="textarea-container">
                                <textarea id="bulk-textarea"
                                       class="bulk-textarea compact auto-grow" 
                                       placeholder="@GetBulkAddPlaceholder()" 
                                       @bind="_bulkItemsText" 
                                       @bind:event="oninput"
                                       @bind:after="HandleTextareaAutoGrow"
                                       @ref="bulkItemsTextarea"
                                       rows="3"
                                       @onkeydown="HandleBulkTextareaKeyDown"></textarea>
                                
                                @if (_isSpeechRecognitionSupported)
                                {
                                    <button type="button" 
                                            class="speech-btn @(_isListening ? "listening" : "")" 
                                            @onclick="ToggleSpeechRecognition"
                                            @onclick:stopPropagation
                                            title="@(_isListening ? AppResources.StopDictation : AppResources.StartDictation)">
                                        <i class="fa @(_isListening ? "fa-stop" : "fa-microphone")" aria-hidden="true"></i>
                                        @if (_isListening)
                                        {
                                            <span class="pulse-ring"></span>
                                        }
                                    </button>
                                }
                                
                                @if (!string.IsNullOrWhiteSpace(_interimTranscript))
                                {
                                    <div class="interim-transcript">
                                        <i class="fa fa-microphone"></i>
                                        <span>@_interimTranscript</span>
                                    </div>
                                }
                            </div>
                            @if (!_isListening && string.IsNullOrWhiteSpace(_bulkItemsText))
                            {
                                <div class="form-hint-mini">
                                    <i class="fa fa-info-circle"></i>
                                    <span>@AppResources.BulkAddHint</span>
                                </div>
                            }
                            @if (_isListening)
                            {
                                <div class="form-hint-mini listening-hint">
                                    <i class="fa fa-microphone"></i>
                                    <span>@AppResources.Listening</span>
                                </div>
                            }
                        </div>
                    </div>
                    
                    <div class="form-actions compact">
                        <button class="btn btn-cancel compact" @onclick="CancelAdd">
                            <i class="fa fa-times"></i>
                            <span>@AppResources.Cancel</span>
                        </button>
                        <button class="btn btn-primary compact" 
                                @onclick="ConfirmBulkAddAsync" 
                                disabled="@(string.IsNullOrWhiteSpace(_bulkItemsText))">
                            <i class="fa fa-check"></i>
                            <span>@AppResources.AddItem</span>
                        </button>
                    </div>
                </div>
            }

            @foreach (var category in _categoryOrder)
            {
                var groupItems = Items.Where(i => string.Equals(i.Item.Category, category, StringComparison.OrdinalIgnoreCase)).ToList();
                if (!groupItems.Any())
                    continue;

                var allChecked = IsAllChecked(category);
                var collapsed = IsCollapsed(category);
                var categoryId = $"cat-{category}";
                var localizedCategory = GetLocalizedCategoryName(category);

                <section class="category @(allChecked ? "category-completed" : "")" aria-labelledby="@categoryId">
                    <div class="category-header" role="button" @onclick="() => ToggleCategory(category)" aria-expanded="@(!collapsed)">
                        <span class="chev @(collapsed ? "collapsed" : "")" aria-hidden="true">
                            <i class="fa fa-chevron-down"></i>
                        </span>
                        <h4 id="@categoryId" class="category-title @(allChecked ? "checked" : "")">@localizedCategory</h4>
                        <span class="count">(@groupItems.Count)</span>
                    </div>

                    <ul class="category-content @(collapsed ? "hidden" : "")">
                        @foreach (var item in groupItems)
                        {
                            var itemId = $"item-{item.Item.Id}";
                            <li class="@GetPackingRowClass(item)"
                                id="@itemId"
                                draggable="true"
                                @ondragstart="@((DragEventArgs e) => OnDragStart(e, item))"
                                @ondragend="@((DragEventArgs e) => OnDragEnd(e, item))"
                                @ondragover:preventDefault
                                @ondragover="@(async (DragEventArgs e) => await OnDragOver(e, item))"
                                @ondragenter:preventDefault
                                @ondragenter="@((DragEventArgs e) => OnDragEnter(e, item))"
                                @ondragleave="@((DragEventArgs e) => OnDragLeave(e, item))"
                                @ondrop:preventDefault
                                @ondrop="@(async (DragEventArgs e) => await OnDrop(e, item))">
                                
                                @if (_editingItem == item)
                                {
                                    <div class="item-edit-container">
                                        <div class="item-edit-header">
                                            <input type="text" 
                                                   value="@item.Item.Name" 
                                                   @oninput="@((e) => UpdateItemName(item, e.Value?.ToString()))"
                                                   @onfocus="@(e => SelectAllInputText(e))"
                                                   @ref="itemEditInputElement"
                                                   class="edit-item-input"
                                                   @onkeydown="@(e => HandleItemEditKeyDown(e, item))"
                                                   placeholder="@AppResources.ItemName"
                                                   @onclick:stopPropagation />
                                        </div>
    
                                        <div class="edit-notes">
                                            <textarea placeholder="@AppResources.AddNotesAboutItem" 
                                                      @bind="item.Item.Notes"
                                                      @bind:event="oninput"
                                                      rows="2"
                                                      class="edit-notes-textarea"></textarea>
                                        </div>
    
                                        <div class="item-edit-actions">
                                            <button class="btn secondary btn-sm" @onclick="() => CancelItemEdit(item)" @onclick:stopPropagation title="@AppResources.Cancel">
                                                <i class="fa fa-times"></i> @AppResources.Cancel
                                            </button>
                                            <button class="btn primary btn-sm" @onclick="() => SaveItemChanges(item)" @onclick:stopPropagation title="@AppResources.Save">
                                                <i class="fa fa-check"></i> @AppResources.Save
                                            </button>
                                        </div>
                                    </div>
                                }
                                else
                                {
                                    <div class="item-display" @onclick="() => StartEditingItem(item)" @onclick:stopPropagation>
                                        <span class="item-text">
                                            @item.Item.Name
                                        </span>
                                        
                                        @if (!string.IsNullOrWhiteSpace(item.Item.Notes))
                                        {
                                            <div class="notes">
                                                @item.Item.Notes
                                            </div>
                                        }
                                    </div>
                                    
                                    <button class="item-delete-btn" 
                                            @onclick="() => PromptDelete(item)"
                                            @onclick:stopPropagation
                                            title="@AppResources.DeleteItemTitle"
                                            aria-label="@string.Format(AppResources.DeleteItemMessage, item.Item.Name)">
                                        <i class="fa fa-trash" aria-hidden="true"></i>
                                    </button>
                                }
                            </li>
                        }
                    </ul>
                </section>
            }
        </div>
    </main>
</div>

<div class="quick-add-container" @onclick:stopPropagation @ref="_quickAddContainerRef">
    <div class="quick-add-form">
        <input type="text" 
               @bind="_quickAddName" 
               @bind:event="oninput"
               @ref="_quickAddInputRef"
               placeholder="@AppResources.TypeItemNameForQuickAdd" 
               class="quick-add-input" />
               
        <div class="quick-category-select">
            <button type="button" 
                   class="category-btn" 
                   title="@GetLocalizedCategoryName(_quickAddCategory)" 
                   @onclick="ToggleQuickCategoryDropdown">
                <i class="fa @GetCategoryIcon(Enum.Parse<PackingCategory>(_quickAddCategory))" aria-hidden="true"></i>
            </button>
            
            @if (_showQuickCategoryDropdown)
            {
                <div class="options-dropdown @(_dropdownPosition == "up" ? "dropdown-up" : "dropdown-down")" @ref="dropdownElement">
                    <div class="dropdown-heading">@AppResources.SelectCategory</div>
                    @foreach (var category in Enum.GetValues<PackingCategory>())
                    {
                        <div class="option @(category.ToString() == _quickAddCategory ? "selected" : "")" 
                             @onclick:stopPropagation
                             @onclick="() => SelectQuickCategory(category.ToString())">
                            <i class="fa @GetCategoryIcon(category)" aria-hidden="true"></i>
                            <span>@GetLocalizedCategoryName(category)</span>
                        </div>
                    }
                </div>
            }
        </div>
        
        <button class="quick-add-btn @(string.IsNullOrWhiteSpace(_quickAddName) ? "disabled" : "")" 
                @onclick="QuickAddItem" 
                disabled="@string.IsNullOrWhiteSpace(_quickAddName)"
                title="@(string.IsNullOrWhiteSpace(_quickAddName) ? AppResources.EnterItemNameFirst : AppResources.AddItem)">
            <i class="fa fa-plus"></i>
        </button>
    </div>
</div>

@code {
    [Parameter]
    public string Id { get; set; } = string.Empty;

    private bool _isAddingItem = false;
    private bool _isLoading;
    private bool _keyboardVisible;
    private double _keyboardHeight;
    private Storage.PackingActivity _currentActivity = new Storage.PackingActivity();
    private string _activityName = string.Empty;

    private sealed class PackingItemView
    {
        public PackingItemView(Storage.PackingItem item) => Item = item;
        public Storage.PackingItem Item { get; }
        public bool IsChecked { get; set; }
    }

    private PackingItemView? _editingItem = null;
    private ElementReference itemEditInputElement;
    private ElementReference bulkItemsTextarea;
    
    private ElementReference _quickAddInputRef;
    private ElementReference _quickAddContainerRef;

    private List<PackingItemView> Items { get; set; } = new();
    private List<string> _categoryOrder = new();
    private readonly Dictionary<string, bool?> _manualOverride = new(StringComparer.OrdinalIgnoreCase);

    private string _newCategory = string.Empty;
    private string _bulkItemsText = string.Empty;

    private PackingItemView? _draggedItem;
    private PackingItemView? _dragOverItem;
    private bool _isDragging = false;
    private string _dropLinePosition = ""; // "before" or "after"

    private bool _showCategorySelector = false;

    private string _quickAddName = string.Empty;
    private string _quickAddCategory = PackingCategory.Miscellaneous.ToString();

    private string _dropdownPosition = "down";
    private ElementReference dropdownElement;
    private bool _showQuickCategoryDropdown = false;
    
    // Speech recognition state
    private bool _isSpeechRecognitionSupported = false;
    private bool _isListening = false;
    private DotNetObjectReference<EditPacking>? _dotNetHelper;
    private string _interimTranscript = string.Empty;

    private void ToggleQuickCategoryDropdown()
    {
        _showQuickCategoryDropdown = !_showQuickCategoryDropdown;

        if (_showQuickCategoryDropdown)
        {
            _ = DetermineDropdownPosition();
        }
    }

    private async Task DetermineDropdownPosition()
    {
        await Task.Delay(1);
        var shouldOpenUp = await JSRuntime.InvokeAsync<bool>("shouldOpenDropdownUp", dropdownElement);
        _dropdownPosition = shouldOpenUp ? "up" : "down";
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            KeyboardService.Initialize(this);
            
            // Check if speech recognition is supported
            try
            {
                _isSpeechRecognitionSupported = await JSRuntime.InvokeAsync<bool>("isSpeechRecognitionSupported");
            }
            catch
            {
                _isSpeechRecognitionSupported = false;
            }
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async Task QuickAddItem()
    {
        var name = _quickAddName.Trim();

        if (string.IsNullOrWhiteSpace(name) || string.IsNullOrWhiteSpace(Id))
            return;

        var newItem = new Storage.PackingItem 
        { 
            Name = name, 
            Category = _quickAddCategory,
            Notes = string.Empty,
            ActivityId = Id 
        };

        try
        {
            await PackingRepository.AddItemToActivityAsync(Id, newItem);
            var newItemView = new PackingItemView(newItem);
            Items.Add(newItemView);

            if (!_categoryOrder.Contains(_quickAddCategory, StringComparer.OrdinalIgnoreCase))
            {
                _categoryOrder.Add(_quickAddCategory);
                _manualOverride[_quickAddCategory] = false;
            }

            _quickAddName = string.Empty;
            StateHasChanged();
            
            // Keep focus on input to continue adding items
            await Task.Delay(50); // Small delay to ensure state update
            await JSRuntime.InvokeVoidAsync("focusElement", _quickAddInputRef);
        }
        catch (Exception ex)
        {
            ToastService.ShowError(string.Format(AppResources.ErrorAddingItem, ex.Message));
        }
    }

    private void HandlePageClick()
    {
        // Blur the quick-add input to hide keyboard when clicking outside
        _ = JSRuntime.InvokeVoidAsync("blurQuickAddInput");
    }

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(Id))
        {
            await LoadItemsForPackingAsync(Id);
        }
        else
        {
            InitializeDefaultItems();
        }

        KeyboardService.KeyboardVisibilityChanged += OnKeyboardVisibilityChanged;

        await base.OnInitializedAsync();
    }

    private void InitializeDefaultItems()
    {
        _currentActivity = new Storage.PackingActivity { Name = AppResources.NewPackingActivity };
        _activityName = _currentActivity.Name;
        Items = new List<PackingItemView>();
        _categoryOrder = Items.Select(i => i.Item.Category).Distinct(StringComparer.OrdinalIgnoreCase).ToList();
        foreach (var cat in _categoryOrder)
            _manualOverride[cat] = null;
    }

    private async Task LoadItemsForPackingAsync(string id)
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            _currentActivity = await PackingRepository.GetByIdAsync(id) ?? new Storage.PackingActivity(){ Name = AppResources.NewPackingActivity };
            _activityName = _currentActivity.Name ?? AppResources.NewPackingActivity;
            NavigationHeaderService.SetText(_currentActivity.Name ?? "");
            var itemsFromRepo = await PackingRepository.GetItemsForActivityAsync(id);
            Items = itemsFromRepo.Select(pi => new PackingItemView(pi)).ToList();
            _categoryOrder = Items.Select(i => i.Item.Category).Distinct(StringComparer.OrdinalIgnoreCase).ToList();

            if (!_categoryOrder.Any())
            {
                _categoryOrder.Add(PackingCategory.Miscellaneous.ToString());
            }

            _manualOverride.Clear();
            foreach (var cat in _categoryOrder)
                _manualOverride[cat] = null;
        }
        catch (Exception ex)
        {
            ToastService.ShowError(AppResources.FailedToLoadItems);
        }
        finally
        {
            _isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ToggleCategory(string category)
    {
        var currentlyCollapsed = IsCollapsed(category);
        _manualOverride[category] = !currentlyCollapsed;
    }

    private bool IsAllChecked(string category)
    {
        var group = Items.Where(i => string.Equals(i.Item.Category, category, StringComparison.OrdinalIgnoreCase));
        return group.Any() && group.All(i => i.IsChecked);
    }

    private bool IsCollapsed(string category)
    {
        if (_manualOverride.TryGetValue(category, out var manual) && manual.HasValue)
            return manual.Value;

        return IsAllChecked(category);
    }

    private void ShowAddItemForm()
    {
        _isAddingItem = true;
        if (_categoryOrder.Any())
        {
            _newCategory = _categoryOrder.First();
        }
        else
        {
            _newCategory = PackingCategory.Miscellaneous.ToString();
        }
    }

    private void CancelAdd()
    {
        _isAddingItem = false;
        _bulkItemsText = string.Empty;
    }

    private async Task ConfirmBulkAddAsync()
    {
        if (string.IsNullOrWhiteSpace(_bulkItemsText) || string.IsNullOrWhiteSpace(Id))
            return;

        var category = string.IsNullOrWhiteSpace(_newCategory) ? PackingCategory.Miscellaneous.ToString() : _newCategory.Trim();

        // Split by both newlines and commas
        var items = _bulkItemsText
            .Split(new[] { "\r\n", "\r", "\n", "," }, StringSplitOptions.RemoveEmptyEntries)
            .Select(line => line.Trim())
            .Where(line => !string.IsNullOrWhiteSpace(line))
            .ToList();

        if (!items.Any())
            return;

        int addedCount = 0;
        int failedCount = 0;

        try
        {
            foreach (var itemName in items)
            {
                try
                {
                    var newItem = new Storage.PackingItem 
                    { 
                        Name = itemName, 
                        Category = category, 
                        Notes = string.Empty, 
                        ActivityId = Id 
                    };

                    await PackingRepository.AddItemToActivityAsync(Id, newItem);
                    addedCount++;
                }
                catch
                {
                    failedCount++;
                }
            }

            await LoadItemsForPackingAsync(Id);
            _manualOverride[category] = false;

            if (addedCount > 0)
            {
                var message = addedCount == 1 
                    ? string.Format(AppResources.ItemAdded, items[0])
                    : string.Format(AppResources.ItemsAdded, addedCount);
                ToastService.ShowSuccess(message);
            }

            if (failedCount > 0)
            {
                ToastService.ShowError(string.Format(AppResources.FailedToAddItems, failedCount));
            }
        }
        catch (Exception ex)
        {
            ToastService.ShowError(string.Format(AppResources.ErrorAddingItem, ex.Message));
        }

        _isAddingItem = false;
        _bulkItemsText = string.Empty;
        StateHasChanged();
    }

    private void OnKeyboardVisibilityChanged(bool isVisible, double height)
    {
        _keyboardVisible = isVisible;
        _keyboardHeight = height;

        if (isVisible)
        {
            // Adjust page padding to account for keyboard height
            _ = JSRuntime.InvokeVoidAsync("adjustPageForKeyboard", height);
            
            // Scroll the active input into view to ensure it's not covered by the keyboard
            _ = JSRuntime.InvokeVoidAsync("scrollActiveElementIntoView");
        }
        else
        {
            // Remove padding when keyboard hides
            _ = JSRuntime.InvokeVoidAsync("adjustPageForKeyboard", 0);
        }
    }

    private string GetBulkAddPlaceholder()
    {
        return AppResources.ResourceManager.GetString("BulkAddPlaceholder", LocalizationService.CurrentCulture) 
            ?? "Enter items (one per line):\nToothbrush\nToothpaste\nShampoo";
    }

    private async Task PromptDelete(PackingItemView item)
    {
        if (string.IsNullOrWhiteSpace(Id))
            return;

        try
        {
            await PackingRepository.DeleteItemAsync(item.Item.Id);
            await LoadItemsForPackingAsync(Id);
            ToastService.ShowSuccess(string.Format(AppResources.ItemDeleted, item.Item.Name));
        }
        catch (Exception ex)
        {
            ToastService.ShowError(string.Format(AppResources.FailedToDeleteItem, ex.Message));
        }
    }

    private async Task CopyPacking()
    {
        if (string.IsNullOrWhiteSpace(Id))
            return;

        try
        {
            var newId = await PackingRepository.CopyPackingAsync(Id);
            ToastService.ShowSuccess(AppResources.PackingActivityCopied);
            Navigation.NavigateTo($"/edit-packing/{newId}");
        }
        catch (Exception ex)
        {
            ToastService.ShowError(string.Format(AppResources.FailedToCopyActivity, ex.Message));
        }
    }

    private async Task PromptDeleteActivity()
    {
        bool confirm = await DialogService.ShowConfirmAsync(
            AppResources.DeleteActivity, 
            AppResources.DeleteActivityConfirm,
            AppResources.Delete,
            AppResources.Cancel);
            
        if (confirm)
        {
            await ConfirmDeleteActivityAsync();
        }
    }

    private async Task ConfirmDeleteActivityAsync()
    {
        if (string.IsNullOrWhiteSpace(Id))
            return;

        try
        {
            await PackingRepository.DeleteAsync(Id);
            ToastService.ShowSuccess(AppResources.PackingActivityDeleted);
            Navigation.NavigateTo("/packing-activities");
        }
        catch (Exception ex)
        {
            ToastService.ShowError(string.Format(AppResources.FailedToDeleteActivity, ex.Message));
        }
    }

    private async Task SaveActivityNameAsync()
    {
        if (string.IsNullOrWhiteSpace(Id))
            return;

        // Trim the activity name
        _activityName = _activityName?.Trim() ?? string.Empty;

        // Don't save if name is empty or unchanged
        if (string.IsNullOrWhiteSpace(_activityName) || _activityName == _currentActivity?.Name)
            return;

        try
        {
            _currentActivity.Name = _activityName;
            await PackingRepository.AddOrUpdateAsync(_currentActivity);
            NavigationHeaderService.SetText(_activityName);
            ToastService.ShowSuccess(AppResources.ItemUpdated);
        }
        catch (Exception ex)
        {
            ToastService.ShowError(string.Format(AppResources.FailedToUpdateItem, ex.Message));
            // Revert to original name on error
            _activityName = _currentActivity?.Name ?? AppResources.NewPackingActivity;
            StateHasChanged();
        }
    }

    // Drag & drop handlers
    private void OnDragStart(DragEventArgs e, PackingItemView item)
    {
        _draggedItem = item;
        _dragOverItem = null;
        _isDragging = true;
        StateHasChanged();

        try
        {
            if (e.DataTransfer is not null)
            {
                e.DataTransfer.DropEffect = "move";
                e.DataTransfer.EffectAllowed = "move";
            }
            
            // Add class to body for dimming effect
            _ = JSRuntime.InvokeVoidAsync("document.body.classList.add", "dragging-active");
        }
        catch
        {
        }
    }

    private void OnDragEnd(DragEventArgs e, PackingItemView item)
    {
        try
        {
            // Clean up: remove dragging class from body
            _ = JSRuntime.InvokeVoidAsync("document.body.classList.remove", "dragging-active");
        }
        catch { }

        // Reset drag state
        _draggedItem = null;
        _dragOverItem = null;
        _isDragging = false;
        StateHasChanged();
    }

    private async Task OnDragOver(DragEventArgs e, PackingItemView item)
    {
        try
        {
            if (e.DataTransfer is not null)
                e.DataTransfer.DropEffect = "move";
            
            // Update drop line position based on mouse Y coordinate
            if (_draggedItem != null && !ReferenceEquals(_draggedItem, item) && e.ClientY > 0)
            {
                var itemId = $"item-{item.Item.Id}";
                var position = await JSRuntime.InvokeAsync<string>("getDropLinePosition", itemId, e.ClientY);
                
                if (_dropLinePosition != position)
                {
                    _dropLinePosition = position;
                    StateHasChanged();
                }
            }
        }
        catch { }
    }

    private void OnDragEnter(DragEventArgs e, PackingItemView item)
    {
        if (_draggedItem != null && !ReferenceEquals(_draggedItem, item))
        {
            _dragOverItem = item;
            // Position will be set by OnDragOver
            if (string.IsNullOrEmpty(_dropLinePosition))
            {
                _dropLinePosition = "after";
            }
            StateHasChanged();
        }
    }

    private void OnDragLeave(DragEventArgs e, PackingItemView item)
    {
        if (ReferenceEquals(_dragOverItem, item))
        {
            _dragOverItem = null;
            _dropLinePosition = "";
            StateHasChanged();
        }
    }

    private string GetPackingRowClass(PackingItemView item)
    {
        var baseClass = "packing-row";
        if (ReferenceEquals(item, _draggedItem))
            return $"{baseClass} dragging";
        if (ReferenceEquals(item, _dragOverItem))
            return $"{baseClass} drag-over drop-line-{_dropLinePosition}";
        if (ReferenceEquals(item, _editingItem))
            return $"{baseClass} editing";
        return baseClass;
    }

    private async Task OnDrop(DragEventArgs e, PackingItemView target)
    {
        try
        {
            // Remove dragging class from body
            _ = JSRuntime.InvokeVoidAsync("document.body.classList.remove", "dragging-active");
        }
        catch { }

        if (_draggedItem is null)
            return;

        var dragged = _draggedItem;
        if (ReferenceEquals(dragged, target))
        {
            _draggedItem = null;
            _dragOverItem = null;
            _dropLinePosition = "";
            return;
        }

        var oldCategory = dragged.Item.Category;
        var categoryChanged = !string.Equals(dragged.Item.Category, target.Item.Category, StringComparison.OrdinalIgnoreCase);

        Items.Remove(dragged);

        if (string.Equals(dragged.Item.Category, target.Item.Category, StringComparison.OrdinalIgnoreCase))
        {
            var targetIndex = Items.IndexOf(target);
            if (targetIndex < 0)
            {
                Items.Add(dragged);
            }
            else
            {
                // Respect the drop line position (before/after)
                if (_dropLinePosition == "before")
                {
                    Items.Insert(targetIndex, dragged);
                }
                else
                {
                    Items.Insert(targetIndex + 1, dragged);
                }
            }
        }
        else
        {
            dragged.Item.Category = target.Item.Category;

            var lastIndex = Items.FindLastIndex(i => string.Equals(i.Item.Category, target.Item.Category, StringComparison.OrdinalIgnoreCase));
            if (lastIndex < 0)
            {
                Items.Add(dragged);
            }
            else
            {
                Items.Insert(lastIndex + 1, dragged);
            }

            if (!Items.Any(i => string.Equals(i.Item.Category, oldCategory, StringComparison.OrdinalIgnoreCase)))
            {
                _categoryOrder.RemoveAll(c => string.Equals(c, oldCategory, StringComparison.OrdinalIgnoreCase));
                _manualOverride.Remove(oldCategory);
            }

            if (!_categoryOrder.Any(c => string.Equals(c, target.Item.Category, StringComparison.OrdinalIgnoreCase)))
            {
                _categoryOrder.Add(target.Item.Category);
                _manualOverride[target.Item.Category] = null;
            }
        }

        _manualOverride[target.Item.Category] = false;

        _draggedItem = null;
        _dragOverItem = null;
        _dropLinePosition = "";
        _isDragging = false;

        // Show toast notification for category changes
        if (categoryChanged)
        {
            var localizedNewCategory = GetLocalizedCategoryName(target.Item.Category);
            ToastService.ShowSuccess($"📦 Moved to {localizedNewCategory}");
        }
        else
        {
            ToastService.ShowSuccess("↕️ Item reordered");
        }

        // Update sort order for all items and persist to database
        await UpdateAndSaveItemsOrder();

        StateHasChanged();
    }

    private bool _isSavingBeforeNav;

    private async Task OnBeforeInternalNavigation(LocationChangingContext context)
    {
        if (_isSavingBeforeNav)
            return;

        if (string.IsNullOrWhiteSpace(Id))
            return;

        _isSavingBeforeNav = true;
        try
        {
            context.PreventNavigation();
            
            // Save activity details
            await PackingRepository.AddOrUpdateAsync(_currentActivity);
            
            // Save items order before navigating
            await UpdateAndSaveItemsOrder();
            
            Navigation.NavigateTo(context.TargetLocation);
        }
        finally
        {
            _isSavingBeforeNav = false;
        }
    }

    private void ToggleCategorySelector()
    {
        _showCategorySelector = !_showCategorySelector;
    }

    private void SelectCategory(PackingCategory category)
    {
        _showCategorySelector = false;
    }

    private string GetCategoryIcon(PackingCategory category)
    {
        return category switch
        {
            PackingCategory.Clothing => "fa-tshirt",
            PackingCategory.Shoes => "fa-shoe-prints",
            PackingCategory.Toiletries => "fa-toothbrush",
            PackingCategory.Electronics => "fa-laptop",
            PackingCategory.Documents => "fa-passport",
            PackingCategory.Health => "fa-medkit",
            PackingCategory.Accessories => "fa-glasses",
            PackingCategory.Outdoor => "fa-hiking",
            PackingCategory.Food => "fa-utensils",
            PackingCategory.Entertainment => "fa-gamepad",
            PackingCategory.Miscellaneous => "fa-box",
            _ => "fa-box"
        };
    }

    private string GetLocalizedCategoryName(PackingCategory category)
    {
        var resourceKey = LocalizationService.GetLocalizedCategory(category.ToString());
        return AppResources.ResourceManager.GetString(resourceKey, LocalizationService.CurrentCulture) ?? category.ToString();
    }

    private string GetLocalizedCategoryName(string categoryString)
    {
        if (Enum.TryParse<PackingCategory>(categoryString, out var category))
        {
            return GetLocalizedCategoryName(category);
        }
        return categoryString;
    }

    private async Task StartEditingItem(PackingItemView item)
    {
        // Don't trigger edit if we're currently dragging
        if (_isDragging)
            return;

        _editingItem = item;
        StateHasChanged();
        
        // Delay to ensure DOM is ready and rendered
        await Task.Delay(100);
        
        // Focus on the edit input
        try
        {
            await JSRuntime.InvokeVoidAsync("focusElement", itemEditInputElement);
            await Task.Delay(50);
            await JSRuntime.InvokeVoidAsync("ensureElementVisible", itemEditInputElement, _keyboardHeight);
        }
        catch
        {
            // ignore - element may not be present in DOM
        }
    }
    
    private async Task SelectAllInputText(FocusEventArgs e)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("selectAllText", itemEditInputElement);
            // Ensure element is visible with a small delay
            await Task.Delay(100);
            await JSRuntime.InvokeVoidAsync("ensureElementVisible", itemEditInputElement, _keyboardHeight);
        }
        catch
        {
            // ignore
        }
    }

    private void UpdateItemName(PackingItemView item, string? newName)
    {
        if (newName != null)
        {
            item.Item.Name = newName;
        }
    }

    private async Task SaveItemChanges(PackingItemView item)
    {
        if (string.IsNullOrWhiteSpace(Id))
            return;

        try
        {
            if (string.IsNullOrWhiteSpace(item.Item.Name))
            {
                item.Item.Name = AppResources.UnnamedItem;
            }

            await PackingRepository.AddOrUpdateItemAsync(item.Item);
            ToastService.ShowSuccess(AppResources.ItemUpdated);
        }
        catch (Exception ex)
        {
            ToastService.ShowError(string.Format(AppResources.FailedToUpdateItem, ex.Message));
        }
        finally
        {
            _editingItem = null;
            StateHasChanged();
        }
    }

    private void SwitchToPackingMode()
    {
        if (!string.IsNullOrEmpty(Id))
        {
            Navigation.NavigateTo($"/play-packing/{Id}");
        }
    }

    private void HandleItemEditKeyDown(KeyboardEventArgs e, PackingItemView item)
    {
        if (e.Key == "Escape")
        {
            CancelItemEdit(item);
        }
        else if (e.Key == "Enter" && !e.ShiftKey)
        {
            _ = SaveItemChanges(item);
        }
    }

    private async Task CancelItemEdit(PackingItemView item)
    {
        _editingItem = null;
        StateHasChanged();
    }

    private void HandleBulkTextareaKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && (e.CtrlKey || e.MetaKey))
        {
            _ = ConfirmBulkAddAsync();
        }
    }

    private async Task HandleTextareaAutoGrow()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("autoGrowTextarea", bulkItemsTextarea);
        }
        catch
        {
            // Silently fail if JS function not available
        }
    }

    private void SelectQuickCategory(string category)
    {
        _quickAddCategory = category;
        _showQuickCategoryDropdown = false;
    }

    private async Task UpdateAndSaveItemsOrder()
    {
        // Update SortOrder for all items based on their current position in the Items list
        for (int i = 0; i < Items.Count; i++)
        {
            Items[i].Item.SortOrder = i;
        }

        // Save all items to database with their new sort order
        if (!string.IsNullOrWhiteSpace(Id))
        {
            try
            {
                await PackingRepository.UpdateItemsSortOrderAsync(Items.Select(x => x.Item));
            }
            catch (Exception ex)
            {
                ToastService.ShowError($"Failed to save item order: {ex.Message}");
            }
        }
    }

    // Speech recognition methods
    private async Task ToggleSpeechRecognition()
    {
        if (!_isSpeechRecognitionSupported)
        {
            ToastService.ShowError(AppResources.SpeechNotSupported);
            return;
        }

        if (_isListening)
        {
            await StopSpeechRecognition();
        }
        else
        {
            await StartSpeechRecognition();
        }
    }

    private async Task StartSpeechRecognition()
    {
        try
        {
            // Request microphone permission before starting speech recognition
            var hasPermission = await PermissionBridge.RequestPermissionAsync();
            
            if (!hasPermission)
            {
                ToastService.ShowError($"{AppResources.MicrophonePermissionDenied}. {AppResources.MicrophonePermissionHelp}");
                _isListening = false;
                StateHasChanged();
                return;
            }

            _dotNetHelper = DotNetObjectReference.Create(this);
            
            // Get the speech recognition language based on current app language
            var speechLanguage = SpeechRecognitionLanguageHelper.GetSpeechRecognitionLanguage(LocalizationService.CurrentCulture);
            
            var initResult = await JSRuntime.InvokeAsync<object>("initializeSpeechRecognition", bulkItemsTextarea, _dotNetHelper, speechLanguage);
            
            // Note: startSpeechRecognition is now async in JavaScript
            var startResult = await JSRuntime.InvokeAsync<JsonElement>("startSpeechRecognition");
            
            // Check if permission was denied at browser level
            if (startResult.TryGetProperty("needsPermission", out var needsPermission) && needsPermission.GetBoolean())
            {
                ToastService.ShowError($"{AppResources.MicrophonePermissionDenied}. {AppResources.MicrophonePermissionHelp}");
                _isListening = false;
                StateHasChanged();
            }
            // Result handling will be done through callbacks
        }
        catch (Exception ex)
        {
            ToastService.ShowError(string.Format(AppResources.SpeechError, ex.Message));
            _isListening = false;
            StateHasChanged();
        }
    }

    private async Task StopSpeechRecognition()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("stopSpeechRecognition");
            _isListening = false;
            _interimTranscript = string.Empty;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            ToastService.ShowError(string.Format(AppResources.SpeechError, ex.Message));
        }
    }

    [JSInvokable]
    public void OnSpeechRecognitionStarted()
    {
        _isListening = true;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnSpeechRecognitionStopped()
    {
        _isListening = false;
        _interimTranscript = string.Empty;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnSpeechRecognitionResult(string finalTranscript, string interimTranscript)
    {
        // Update textbox in real-time with final transcript
        _bulkItemsText = finalTranscript;
        _interimTranscript = interimTranscript;
        StateHasChanged();
    }

    [JSInvokable]
    public void OnSpeechRecognitionError(string error)
    {
        _isListening = false;
        _interimTranscript = string.Empty;
        
        var errorMessage = error switch
        {
            "not-allowed" or "permission-denied" => $"{AppResources.MicrophonePermissionDenied}. {AppResources.MicrophonePermissionHelp}",
            "not-supported" => AppResources.SpeechNotSupported,
            "no-speech" => AppResources.NoSpeechDetected,
            "audio-capture" => AppResources.AudioCaptureError,
            "network" => AppResources.NetworkErrorSpeech,
            "language-not-supported" => AppResources.LanguageNotSupported,
            _ => string.Format(AppResources.SpeechError, error)
        };
        
        ToastService.ShowError(errorMessage);
        StateHasChanged();
    }

    public void Dispose()
    {
        try
        {
            if (KeyboardService != null)
            {
                KeyboardService.KeyboardVisibilityChanged -= OnKeyboardVisibilityChanged;
            }
            
            // Stop speech recognition if active
            if (_isListening)
            {
                _ = JSRuntime.InvokeVoidAsync("stopSpeechRecognition");
            }
            
            // Dispose DotNetObjectReference
            _dotNetHelper?.Dispose();
        }
        catch { }
    }
}
