@page "/packing-dialog"
@using Microsoft.JSInterop
@using Anticipack.Resources.Localization
@implements IAsyncDisposable

<div class="chat-container">
    <div class="messages" @ref="messagesContainer">
        @foreach (var msg in messages)
        {
            <div class="message @(msg.IsSent ? "sent" : "received")">
                <div class="bubble">@msg.Text</div>
                <div class="meta">@msg.Timestamp.ToString("HH:mm")</div>
            </div>
        }
    </div>

    <div class="chat-input">
        <textarea @bind="currentMessage" @bind:event="oninput" placeholder="@AppResources.TypeMessage"
                  rows="2" @ref="messageInput"></textarea>
        <button class="send-btn" @onclick="Send">
            <!-- simple send SVG icon -->
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
                <path d="M2 21L23 12L2 3V10L17 12L2 14V21Z" fill="currentColor"/>
            </svg>
            <span class="sr-only">@AppResources.Send</span>
        </button>
    </div>
</div>

@code {
    [Inject] private IJSRuntime JS { get; set; } = default!;

    private ElementReference messageInput;
    private ElementReference messagesContainer;
    private DotNetObjectReference<PackingDialog>? _dotNetRef;

    private string currentMessage = string.Empty;

    private List<ChatMessage> messages = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // create a DotNet reference so JS can call back when Enter is pressed
            _dotNetRef = DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("packingDialog.attach", messageInput, _dotNetRef, messagesContainer);
            await messageInput.FocusAsync();
        }
    }

    private async Task Send()
    {
        var text = currentMessage?.TrimEnd();
        if (string.IsNullOrWhiteSpace(text))
            return;

        messages.Add(new ChatMessage
        {
            Text = text,
            Timestamp = DateTime.Now,
            IsSent = true
        });

        currentMessage = string.Empty;

        // allow UI to update then scroll to bottom and restore focus
        await InvokeAsync(async () =>
        {
            await Task.Yield();
            await JS.InvokeVoidAsync("packingDialog.scrollToBottom", messagesContainer);
            await messageInput.FocusAsync();
        });
    }

    [JSInvokable]
    public Task SubmitFromJs() => Send();

    public async ValueTask DisposeAsync()
    {
        if (_dotNetRef is not null)
        {
            _dotNetRef.Dispose();
            _dotNetRef = null;
        }

        try
        {
            await JS.InvokeVoidAsync("packingDialog.detach", messageInput);
        }
        catch
        {
            // ignore if JS side not present
        }
    }

    private sealed class ChatMessage
    {
        public string Text { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
        public bool IsSent { get; set; }
    }
}

<script>
    window.packingDialog = {
        attach: function (inputEl, dotNetRef, messagesEl) {
            if (!inputEl) return;
            // store the handler so detach can remove it later
            const handler = function (e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    dotNetRef.invokeMethodAsync('SubmitFromJs');
                }
            };
            inputEl.__packingDialogHandler = handler;
            inputEl.addEventListener('keydown', handler);
            // also store messagesEl for scroll helper
            inputEl.__messagesEl = messagesEl;
        },
        detach: function (inputEl) {
            if (!inputEl) return;
            const handler = inputEl.__packingDialogHandler;
            if (handler) {
                inputEl.removeEventListener('keydown', handler);
                delete inputEl.__packingDialogHandler;
                delete inputEl.__messagesEl;
            }
        },
        scrollToBottom: function (messagesEl) {
            try {
                if (!messagesEl) return;
                messagesEl.scrollTop = messagesEl.scrollHeight;
            } catch (e) {
                // ignore
            }
        }
    };
</script>
