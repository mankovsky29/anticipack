@page "/packing-dialog"
@using Microsoft.JSInterop
@using Anticipack.Resources.Localization
@using Anticipack.Services
@inject IKeyboardService KeyboardService
@implements IAsyncDisposable

<div class="chat-container">
    <div class="messages" @ref="messagesContainer">
        @foreach (var msg in messages)
        {
            <div class="message @(msg.IsSent ? "sent" : "received")">
                <div class="bubble">@msg.Text</div>
                <div class="meta">@msg.Timestamp.ToString("HH:mm")</div>
            </div>
        }
    </div>

    <div class="chat-input">
        <textarea @bind="currentMessage" @bind:event="oninput" placeholder="@AppResources.TypeMessage"
                  rows="2" @ref="messageInput"></textarea>
        <button class="send-btn" @onclick="Send">
            <!-- simple send SVG icon -->
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
                <path d="M2 21L23 12L2 3V10L17 12L2 14V21Z" fill="currentColor"/>
            </svg>
            <span class="sr-only">@AppResources.Send</span>
        </button>
    </div>
</div>

@code {
[Inject] private IJSRuntime JS { get; set; } = default!;

private ElementReference messageInput;
private ElementReference messagesContainer;
private DotNetObjectReference<PackingDialog>? _dotNetRef;

private string currentMessage = string.Empty;

private List<ChatMessage> messages = new();
    
// Keyboard
private bool _keyboardVisible;
private double _keyboardHeight;

protected override async Task OnAfterRenderAsync(bool firstRender)
{
    if (firstRender)
    {
        KeyboardService.Initialize(this);
        KeyboardService.KeyboardVisibilityChanged += OnKeyboardVisibilityChanged;
            
        // create a DotNet reference so JS can call back when Enter is pressed
        _dotNetRef = DotNetObjectReference.Create(this);
        await JS.InvokeVoidAsync("packingDialog.attach", messageInput, _dotNetRef, messagesContainer);
        await messageInput.FocusAsync();
    }
}
    
    private void OnKeyboardVisibilityChanged(bool isVisible, double height)
    {
        _keyboardVisible = isVisible;
        _keyboardHeight = height;

        if (isVisible)
        {
            // Adjust page padding to account for keyboard height
            _ = JS.InvokeVoidAsync("adjustPageForKeyboard", height);
            
            // Scroll the active input into view to ensure it's not covered by the keyboard
            _ = JS.InvokeVoidAsync("scrollActiveElementIntoView");
        }
        else
        {
            // Remove padding when keyboard hides
            _ = JS.InvokeVoidAsync("adjustPageForKeyboard", 0);
        }
    }

    private async Task Send()
    {
        var text = currentMessage?.TrimEnd();
        if (string.IsNullOrWhiteSpace(text))
            return;

        messages.Add(new ChatMessage
        {
            Text = text,
            Timestamp = DateTime.Now,
            IsSent = true
        });

        currentMessage = string.Empty;

        // allow UI to update then scroll to bottom and restore focus
        await InvokeAsync(async () =>
        {
            await Task.Yield();
            await JS.InvokeVoidAsync("packingDialog.scrollToBottom", messagesContainer);
            await messageInput.FocusAsync();
        });
    }

    [JSInvokable]
    public Task SubmitFromJs() => Send();

    public async ValueTask DisposeAsync()
    {
        KeyboardService.KeyboardVisibilityChanged -= OnKeyboardVisibilityChanged;
        
        if (_dotNetRef is not null)
        {
            _dotNetRef.Dispose();
            _dotNetRef = null;
        }

        try
        {
            await JS.InvokeVoidAsync("packingDialog.detach", messageInput);
        }
        catch
        {
            // ignore if JS side not present
        }
    }

    private sealed class ChatMessage
    {
        public string Text { get; set; } = string.Empty;
        public DateTime Timestamp { get; set; }
        public bool IsSent { get; set; }
    }
}

<script>
    window.packingDialog = {
        attach: function (inputEl, dotNetRef, messagesEl) {
            if (!inputEl) return;
            // store the handler so detach can remove it later
            const handler = function (e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    dotNetRef.invokeMethodAsync('SubmitFromJs');
                }
            };
            inputEl.__packingDialogHandler = handler;
            inputEl.addEventListener('keydown', handler);
            // also store messagesEl for scroll helper
            inputEl.__messagesEl = messagesEl;
        },
        detach: function (inputEl) {
            if (!inputEl) return;
            const handler = inputEl.__packingDialogHandler;
            if (handler) {
                inputEl.removeEventListener('keydown', handler);
                delete inputEl.__packingDialogHandler;
                delete inputEl.__messagesEl;
            }
        },
        scrollToBottom: function (messagesEl) {
            try {
                if (!messagesEl) return;
                messagesEl.scrollTop = messagesEl.scrollHeight;
            } catch (e) {
                // ignore
            }
        }
    };
</script>
