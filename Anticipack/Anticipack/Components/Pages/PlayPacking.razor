@page "/play-packing/{id}"
@using Anticipack.Components.Shared.NavigationHeaderComponent
@using Anticipack.Packing
@using Anticipack.Storage
@using System.Threading
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.JSInterop
@using Anticipack.Components.Shared.DialogComponent
@using Anticipack.Components.Shared.ToastComponent
@using Anticipack.Resources.Localization
@using Anticipack.Services.Packing
@inject NavigationManager Navigation
@inject IPackingRepository PackingRepository
@inject IJSRuntime JSRuntime
@inject IDialogService DialogService
@inject IToastService ToastService
@inject INavigationHeaderService NavigationHeaderService
@inject IPackingHistoryService PackingHistoryService
@implements IDisposable

<div class="page-container with-fixed-navbar">
    <div class="activity-header">
        <div class="activity-actions activity-actions-left" role="group" aria-label="@AppResources.PackingDialogMenu">
            <!-- Edit mode button -->
            <button class="icon-btn" 
                    @onclick="SwitchToEditMode" 
                    title="@AppResources.EditActivity">
                <i class="fa fa-edit" aria-hidden="true"></i>
            </button>
        </div>

        <div class="activity-actions activity-actions-right" role="group">
            <!-- Show/Hide toggle -->
            <button class="toggle-visibility-btn @(_hideCheckedItems ? "filtering" : "")" 
                    @onclick="ToggleItemVisibility" 
                    title="@(_hideCheckedItems ? AppResources.ShowAllItems : AppResources.HideCheckedItems)">
                <i class="fa @(_hideCheckedItems ? "fa-eye-slash" : "fa-eye")" aria-hidden="true"></i>
            </button>

            <!-- Reset all items button -->
            <button class="icon-btn" 
                    @onclick="ConfirmResetAllItems" 
                    title="@AppResources.ResetAllItems">
                <i class="fa fa-undo-alt" aria-hidden="true"></i>
            </button>

            <!-- Finish Packing button -->
            <button class="icon-btn" 
                    @onclick="ConfirmFinishPacking" 
                    disabled="@(!CanFinishPacking())"
                    title="@AppResources.FinishPacking">
                <i class="fa fa-check-circle" aria-hidden="true"></i>
            </button>
        </div>
    </div>

    <div class="progress-container">
        <div class="progress-bar">
            <div class="progress-fill" style="width: @($"{GetCompletionPercentage()}%")"></div>
        </div>
        <div class="progress-stats">
            <span>@string.Format(AppResources.ItemsPacked, Items.Count(i => i.IsChecked), Items.Count)</span>
            <span class="time-remaining">@GetEstimatedTimeRemaining()</span>
        </div>
    </div>

    <main class="content-area @(_hideCheckedItems ? "hide-checked" : "")" @onkeydown="HandleKeyboardNavigation" tabindex="0" @ref="contentArea">
        @if (_isLoading)
        {
            <div class="loading">
                <div class="loading-spinner"></div>
                <span>@AppResources.LoadingPacking</span>
            </div>
        }
        else
        {
            @foreach (var category in _categoryOrder)
            {
                var groupItems = Items.Where(i => string.Equals(i.Item.Category, category, StringComparison.OrdinalIgnoreCase))
                                      .Where(i => !(_hideCheckedItems && i.IsChecked && !i.IsAnimating)) // Keep animating items visible
                                      .ToList();
                if (!groupItems.Any())
                    continue;

                var totalCount = Items.Where(i => string.Equals(i.Item.Category, category, StringComparison.OrdinalIgnoreCase)).Count();

                var allChecked = IsAllChecked(category);
                var collapsed = IsCollapsed(category);
                var categoryId = $"cat-{category}";

                <section class="category @(allChecked && !_hideCheckedItems ? "category-completed" : "")" aria-labelledby="@categoryId">
                    <div class="category-header" role="button" @onclick="() => ToggleCategory(category)" aria-expanded="@(!collapsed)">
                        <span class="chev @(collapsed ? "collapsed" : "")" aria-hidden="true">▾</span>
                        <h4 id="@categoryId" class="category-title @(allChecked && !_hideCheckedItems ? "checked" : "")">@category</h4>
                        <span class="count">@(_hideCheckedItems? totalCount - groupItems.Count() : groupItems.Count(x=>x.IsChecked))/@totalCount</span>
                    </div>

                    <ul class="category-content @(collapsed ? "hidden" : "")">
                        @foreach (var item in groupItems)
                        {
                            <li class="packing-row @(item.IsAnimating ? "vanishing" : "")" 
                                @key="item.Item.Id" 
                                @onclick="(e) => HandleRowClick(e, item)"
                                id="item-@item.Item.Id">
                                <div class="item-main">
                                    <div class="round-checkbox">
                                        <input id="@($"checkbox-{item.Item.Id}")" class="item-checkbox" type="checkbox" 
                                               checked="@item.IsChecked"
                                               @onchange="@(async (ChangeEventArgs e) => await HandleItemChecked(item, Convert.ToBoolean(e.Value), null))" 
                                               @onclick:stopPropagation="true" />
                                        <label for="@($"checkbox-{item.Item.Id}")" @onclick:stopPropagation="true"></label>
                                    </div>
                                    <span class="@($"item-text {(item.IsChecked ? "checked" : "")}")">
                                        @item.Item.Name
                                    </span>
                                </div>
                                

                                @if (!string.IsNullOrWhiteSpace(item.Item.Notes))
                                {
                                    <div class="notes">@item.Item.Notes</div>
                                }
                            </li>
                        }
                    </ul>
                </section>
            }
        }
    </main>
</div>

<div class="history-panel @(_showHistory ? "expanded" : "")">
    <div class="history-header" @onclick="ToggleHistory">
        <h4>@AppResources.PackingHistory</h4>
        <span class="chev @(_showHistory ? "" : "collapsed")">▾</span>
    </div>
    
    @if (_showHistory)
    {
        <div class="history-content">
            <div class="history-stats">
                <div class="stat-card">
                    <span class="stat-value">@_currentActivity.RunCount</span>
                    <span class="stat-label">@AppResources.TimesPacked</span>
                </div>
                <div class="stat-card">
                    <span class="stat-value">@_averagePackingTime</span>
                    <span class="stat-label">@AppResources.AvgTime</span>
                </div>
                <div class="stat-card">
                    <span class="stat-value">@_lastPackedDate</span>
                    <span class="stat-label">@AppResources.LastPackedLabel</span>
                </div>
            </div>
            
            <div class="history-timeline">
                <h5>@AppResources.RecentActivity</h5>
                <ul class="timeline-list">
                    @foreach (var entry in _recentHistory)
                    {
                        <li class="timeline-item">
                            <span class="timeline-date">@entry.CompletedDate.ToString("MMM d, HH:mm")</span>
                            <span class="timeline-action">@GetHistoryEntryDescription(entry)</span>
                        </li>
                    }
                </ul>
            </div>
        </div>
    }
</div>

@if (GetCompletionPercentage() == 100 && !_completionAcknowledged)
{
    <div class="modal-overlay celebration">
        <div class="completion-modal">
            <div class="confetti-container">
                <!-- Confetti animation here -->
            </div>
            
            <h3>@AppResources.PackingComplete</h3>
            <p>@string.Format(AppResources.YouPackedItems, Items.Count, GetPackingDuration())</p>
            
            <div class="completion-stats">
                <div class="stat">
                    <span class="label">@AppResources.ComparedToLastTime</span>
                    <span class="value @(_timeComparison?.IsFaster == true ? "better" : "slower")">@(_timeComparison?.FormattedDifference ?? "")</span>
                </div>
            </div>
            
            <button class="btn primary" @onclick="AcknowledgeCompletion">
                @AppResources.Great
            </button>
        </div>
    </div>
}

@code {
    [Parameter]
    public string Id { get; set; } = string.Empty;

    private const int PackedItemAnimationDelayMs = 350;

    private bool _isLoading;
    private DateTime _packingStartTime;
    private bool _showHistory = false;
    private bool _completionAcknowledged = false;
    private bool _hideCheckedItems = true;
    private bool _wasCompleteOnLoad = false; // Track if all items were already checked when page loaded

    private Storage.PackingActivity _currentActivity = new Storage.PackingActivity();
    
    // History data
    private List<Storage.PackingHistoryEntry> _recentHistory = new();
    private string _averagePackingTime = "-";
    private string _lastPackedDate = "-";
    private PackingTimeComparison? _timeComparison;

    private sealed class PackingItemView
    {
        public PackingItemView(Storage.PackingItem item) => Item = item;
        public Storage.PackingItem Item { get; }
        public bool IsChecked { get; set; }
        public bool IsAnimating { get; set; } // Track animation state
    }

    private ElementReference contentArea;
    private int _currentFocusIndex = -1;

    private List<PackingItemView> Items { get; set; } = new();
    private List<string> _categoryOrder = new();
    private readonly Dictionary<string, bool?> _manualOverride = new(StringComparer.OrdinalIgnoreCase);

    protected override async Task OnInitializedAsync()
    {
        _packingStartTime = DateTime.Now;

        if (!string.IsNullOrEmpty(Id))
        {
            await LoadItemsForPackingAsync(Id);
        }

        await base.OnInitializedAsync();
    }

    private async Task LoadItemsForPackingAsync(string id)
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            _currentActivity = await PackingRepository.GetByIdAsync(id) ?? new Storage.PackingActivity(){ Name = AppResources.PackingActivity };
            NavigationHeaderService.SetText(_currentActivity.Name ?? "");
            var itemsFromRepo = await PackingRepository.GetItemsForActivityAsync(id);

            // If activity was previously finished, reset all items to unchecked
            bool shouldResetItems = _currentActivity.IsFinished;

            // Map items from repository and restore/reset their packed state
            Items = itemsFromRepo.Select(pi => new PackingItemView(pi) 
            { 
                IsChecked = shouldResetItems ? false : pi.IsPacked  // Reset if finished, otherwise restore state
            }).ToList();

            // If we reset items, mark activity as not finished and save
            if (shouldResetItems)
            {
                _currentActivity.IsFinished = false;
                await PackingRepository.AddOrUpdateAsync(_currentActivity);
                
                // Also update items in repository
                foreach (var item in Items)
                {
                    item.Item.IsPacked = false;
                    await PackingRepository.AddOrUpdateItemAsync(item.Item);
                }
            }

            // Check if all items were already complete when loaded (only relevant if not reset)
            _wasCompleteOnLoad = !shouldResetItems && Items.Any() && Items.All(i => i.IsChecked);
            if (_wasCompleteOnLoad)
            {
                _completionAcknowledged = true; // Don't show modal for already completed packing
            }

            _categoryOrder = Items.Select(i => i.Item.Category).Distinct(StringComparer.OrdinalIgnoreCase).ToList();

            if (!_categoryOrder.Any())
            {
                _categoryOrder.Add(PackingCategory.Miscellaneous.ToString());
            }

            _manualOverride.Clear();
            foreach (var cat in _categoryOrder)
            {
                // If all items in category are checked, collapse it
                var allChecked = IsAllChecked(cat);
                _manualOverride[cat] = allChecked ? true : false;
            }
            
            // Load history data
            await LoadHistoryDataAsync(id);
        }
        catch
        {
            ToastService.ShowError(AppResources.FailedToLoadItems);
        }
        finally
        {
            _isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private async Task LoadHistoryDataAsync(string activityId)
    {
        try
        {
            // Load recent history
            _recentHistory = await PackingHistoryService.GetRecentHistoryAsync(activityId, 5);
            
            // Load average packing time
            var avgTime = await PackingHistoryService.GetAveragePackingTimeAsync(activityId);
            _averagePackingTime = avgTime is null 
                ? "-" 
                : $"{(int)avgTime.Value.TotalMinutes} min";
            
            // Load last packed date
            var lastSession = await PackingHistoryService.GetLastPackingSessionAsync(activityId);
            _lastPackedDate = lastSession != null 
                ? lastSession.CompletedDate.ToString("MMM d") 
                : "-";
        }
        catch
        {
            // Silently fail if history loading fails
            _averagePackingTime = "-";
            _lastPackedDate = "-";
        }
    }

    private void ToggleCategory(string category)
    {
        var currentlyCollapsed = IsCollapsed(category);
        _manualOverride[category] = !currentlyCollapsed;
    }

    private void SetItemChecked(PackingItemView item, bool isChecked)
    {
        item.IsChecked = isChecked;
        UpdateCategoryStateAfterItemChange(item.Item.Category);
        SaveCheckState(item);
    }

    private void ToggleItemChecked(PackingItemView item)
    {
        item.IsChecked = !item.IsChecked;
        UpdateCategoryStateAfterItemChange(item.Item.Category);
        SaveCheckState(item);
    }

    private async void SaveCheckState(PackingItemView item)
    {
        if (!string.IsNullOrEmpty(Id))
        {
            try
            {
                item.Item.IsPacked = item.IsChecked;
                await PackingRepository.AddOrUpdateItemAsync(item.Item);
            }
            catch (Exception ex)
            {
                ToastService.ShowError(string.Format(AppResources.ErrorSavingItemState, ex.Message));
            }
        }
    }

    private void UpdateCategoryStateAfterItemChange(string category)
    {
        var allChecked = IsAllChecked(category);

        if (allChecked)
            _manualOverride[category] = true; // Auto-collapse category when all its items are packed

        StateHasChanged();

        if (GetCompletionPercentage() == 100 && !_completionAcknowledged)
        {
            // Trigger completion modal - data calculated in AcknowledgeCompletion
            StateHasChanged();
        }
    }

    private bool IsAllChecked(string category)
    {
        var group = Items.Where(i => string.Equals(i.Item.Category, category, StringComparison.OrdinalIgnoreCase));
        return group.Any() && group.All(i => i.IsChecked);
    }

    private bool IsCollapsed(string category)
    {
        if (_manualOverride.TryGetValue(category, out var manual) && manual.HasValue)
            return manual.Value;

        return IsAllChecked(category);
    }

    private void HandleKeyboardNavigation(KeyboardEventArgs e)
    {
        var itemsList = Items.ToList();

        switch (e.Key)
        {
            case "ArrowDown":
                _currentFocusIndex = Math.Min(_currentFocusIndex + 1, itemsList.Count - 1);
                break;
            case "ArrowUp":
                _currentFocusIndex = Math.Max(_currentFocusIndex - 1, 0);
                break;
            case " ": // Space key
                if (_currentFocusIndex >= 0 && _currentFocusIndex < itemsList.Count)
                    ToggleItemChecked(itemsList[_currentFocusIndex]);
                break;
        }

        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("focusElement", contentArea);
        }
    }

    private void ToggleHistory()
    {
        _showHistory = !_showHistory;
    }

    private int GetCompletionPercentage() => 
        Items.Any() ? (int)(Items.Count(i => i.IsChecked) * 100.0 / Items.Count) : 0;

    private string GetEstimatedTimeRemaining()
    {
        var itemsLeft = Items.Count(i => !i.IsChecked);
        
        if (itemsLeft == 0)
            return AppResources.Done;
        
        // Use default estimation: 30 seconds per item
        // Cannot use async calls in synchronous rendering methods - causes deadlocks
        var defaultMinutes = Math.Ceiling(itemsLeft * 0.5);
        return string.Format(AppResources.MinRemaining, defaultMinutes);
    }

    private string GetHistoryEntryDescription(Storage.PackingHistoryEntry entry)
    {
        var durationMinutes = (int)(entry.DurationSeconds / 60.0);
        return $"Packed {entry.PackedItems} items in {durationMinutes} minutes";
    }

    private string GetPackingDuration()
    {
        var duration = DateTime.Now - _packingStartTime;
        return $"{(int)duration.TotalMinutes} minutes";
    }

    private async Task AcknowledgeCompletion()
    {
        try
        {
            var endTime = DateTime.Now;
            var packedItems = Items.Count(i => i.IsChecked);
            
            // Compare with average
            _timeComparison = await PackingHistoryService.CompareWithAverageAsync(Id, endTime - _packingStartTime);
            
            // Record completion in history
            await PackingHistoryService.RecordPackingSessionAsync(
                Id, 
                _packingStartTime, 
                endTime, 
                Items.Count, 
                packedItems
            );
            
            // Update activity
            _currentActivity.LastPacked = endTime;
            _currentActivity.RunCount++;
            _currentActivity.IsFinished = true; // Mark as finished

            // Save to repository
            if (!string.IsNullOrWhiteSpace(Id))
            {
                await PackingRepository.AddOrUpdateAsync(_currentActivity);
                
                // Reload history data
                await LoadHistoryDataAsync(Id);
            }
            
            _completionAcknowledged = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            ToastService.ShowError($"Error saving completion: {ex.Message}");
            _completionAcknowledged = true;
        }
    }

    private async Task SwitchToEditMode()
    {
        if(Items.Count(i => i.IsChecked) > 0)
        {
            bool confirm = await DialogService.ShowConfirmAsync(
                AppResources.SwitchToEditMode, 
                AppResources.EditingMightAffectProgress, 
                AppResources.ContinueToEdit, 
                AppResources.Cancel);

            if (confirm)
            {
                NavigateToEditMode();
            }
        }
        else
        {
            NavigateToEditMode();
        }
    }

    private void NavigateToEditMode()
    {
        if (!string.IsNullOrEmpty(Id))
        {
            Navigation.NavigateTo($"/edit-packing/{Id}");
        }
    }

    public void Dispose()
    {
        // No toast cleanup needed anymore
    }

    private void ToggleItemVisibility()
    {
        _hideCheckedItems = !_hideCheckedItems;
    }

    private async Task ConfirmResetAllItems()
    {
        bool confirm = await DialogService.ShowConfirmAsync(
            AppResources.ResetPackingList, 
            AppResources.ConfirmResetAllItems, 
            AppResources.ResetAll, 
            AppResources.Cancel);

        if (confirm)
        {
            await ResetAllItems();
            ExpandAllCategories();
        }
    }

    private void ExpandAllCategories()
    {
        foreach (var key in _manualOverride.Keys)
        {
            _manualOverride[key] = false; // false it is expanded
        }
    }

    private async Task ResetAllItems()
    {
        // Count how many items were checked before reset
        int checkedItemsCount = Items.Count(i => i.IsChecked);
        
        foreach (var item in Items)
        {
            item.IsChecked = false;
            item.Item.IsPacked = false;
        }
        
        // Reset completion acknowledgment so modal can show again if user completes it
        _completionAcknowledged = false;
        _wasCompleteOnLoad = false;

        // Reset packing start time for fresh duration tracking
        _packingStartTime = DateTime.Now;
        
        // Save to repository
        if (!string.IsNullOrEmpty(Id))
        {
            try
            {
                foreach (var item in Items)
                {
                    await PackingRepository.AddOrUpdateItemAsync(item.Item);
                }
                
                // Show a toast with the result
                ToastService.ShowInfo(string.Format(AppResources.ResetItemsSuccess, checkedItemsCount));
                
                // Refresh categories state
                foreach (var category in _categoryOrder)
                {
                    UpdateCategoryStateAfterItemChange(category);
                }
                
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                ToastService.ShowError(string.Format(AppResources.ErrorResettingItems, ex.Message));
            }
        }
    }

    private async Task HandleRowClick(MouseEventArgs e, PackingItemView item)
    {
        await HandleItemChecked(item, !item.IsChecked, e);
    }

    private async Task HandleItemChecked(PackingItemView item, bool isChecked, MouseEventArgs? e)
    {
        // Only apply animation when marking as checked (not unchecking)
        if (!item.IsChecked && isChecked)
        {
            try
            {
                item.IsAnimating = true;
                StateHasChanged(); // Force UI update to show animation starting
                
                item.IsChecked = isChecked;
                await Task.Delay(PackedItemAnimationDelayMs);
                
                UpdateCategoryStateAfterItemChange(item.Item.Category);
                                
                // Save the change to repository
                SaveCheckState(item);
            }
            catch (Exception ex)
            {
                // Fallback if animation fails
                item.IsChecked = isChecked;
                UpdateCategoryStateAfterItemChange(item.Item.Category);
                SaveCheckState(item);
                ToastService.ShowSuccess(string.Format(AppResources.ItemPacked, item.Item.Name));
            }
            finally
            {
                // End animation state
                item.IsAnimating = false;
                
                // Force UI update if needed
                if (_hideCheckedItems)
                {
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        else
        {
            // For unchecking, just update without animation
            item.IsChecked = isChecked;
            
            if (isChecked)
            {
                ToastService.ShowSuccess(string.Format(AppResources.ItemPacked, item.Item.Name));
            }
            else
            {
                ToastService.ShowInfo(string.Format(AppResources.ItemUnpacked, item.Item.Name));
            }
            
            UpdateCategoryStateAfterItemChange(item.Item.Category);
            SaveCheckState(item);
            
            if (_hideCheckedItems)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private bool CanFinishPacking()
    {
        var checkedCount = Items.Count(i => i.IsChecked);
        var totalCount = Items.Count;
        
        // Can finish if at least one item is checked AND not all items are checked
        return checkedCount > 0 && checkedCount < totalCount;
    }

    private async Task ConfirmFinishPacking()
    {
        var packedCount = Items.Count(i => i.IsChecked);
        var totalCount = Items.Count;
        var remainingCount = totalCount - packedCount;
        
        bool confirm = await DialogService.ShowConfirmAsync(
            AppResources.FinishPacking,
            string.Format(AppResources.ConfirmFinishPackingWithAutoCheck, packedCount, totalCount, remainingCount),
            AppResources.FinishNow,
            AppResources.Cancel);

        if (confirm)
        {
            await FinishPackingNow();
        }
    }

    private async Task FinishPackingNow()
    {
        try
        {
            // Automatically check all remaining unchecked items
            var uncheckedItems = Items.Where(i => !i.IsChecked).ToList();
            foreach (var item in uncheckedItems)
            {
                item.IsChecked = true;
                item.Item.IsPacked = true;
                await PackingRepository.AddOrUpdateItemAsync(item.Item);
            }
            
            var endTime = DateTime.Now;
            var packedItems = Items.Count; // All items are now packed
            
            // Compare with average
            _timeComparison = await PackingHistoryService.CompareWithAverageAsync(Id, endTime - _packingStartTime);
            
            // Record completion in history with all items packed
            await PackingHistoryService.RecordPackingSessionAsync(
                Id, 
                _packingStartTime, 
                endTime, 
                Items.Count, 
                packedItems
            );
            
            // Update activity
            _currentActivity.LastPacked = endTime;
            _currentActivity.RunCount++;
            _currentActivity.IsFinished = true; // Mark as finished

            // Save to repository
            if (!string.IsNullOrWhiteSpace(Id))
            {
                await PackingRepository.AddOrUpdateAsync(_currentActivity);
                
                // Reload history data
                await LoadHistoryDataAsync(Id);
            }
            
            // Update UI state for all categories
            foreach (var category in _categoryOrder)
            {
                UpdateCategoryStateAfterItemChange(category);
            }
            
            // Show completion modal
            _completionAcknowledged = false;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            ToastService.ShowError($"Error finishing packing: {ex.Message}");
        }
    }
}
