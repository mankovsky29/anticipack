@page "/play-packing/{id}"
@using Anticipack.Components.Shared.SidebarTextComponent
@using Anticipack.Packing
@using Anticipack.Storage
@using System.Threading
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.JSInterop
@using Anticipack.Components.Shared.DialogComponent
@using Anticipack.Components.Shared.ToastComponent
@using Anticipack.Resources.Localization
@inject NavigationManager Navigation
@inject IPackingRepository PackingRepository
@inject IJSRuntime JSRuntime
@inject IDialogService DialogService
@inject IToastService ToastService
@inject ISidebarTextService SidebarTextService
@implements IDisposable

<div class="page-container with-fixed-navbar">
    <div class="activity-header">
        <div class="activity-actions" role="group" aria-label="@AppResources.PackingDialogMenu">
            <!-- Primary action: Show/Hide toggle -->
            <button class="toggle-visibility-btn @(_hideCheckedItems ? "filtering" : "")" 
                    @onclick="ToggleItemVisibility" 
                    title="@(_hideCheckedItems ? AppResources.ShowAllItems : AppResources.HideCheckedItems)">
                <i class="fa @(_hideCheckedItems ? "fa-eye-slash" : "fa-eye")" aria-hidden="true"></i>
            </button>

            <!-- History toggle button -->
            <button class="icon-btn" 
                    @onclick="ToggleHistory" 
                    title="@(_showHistory ? AppResources.HideHistory : AppResources.ShowHistory)">
                <i class="fa @(_showHistory ? "fa-chevron-down" : "fa-list-ul")" aria-hidden="true"></i>
            </button>

            <!-- Reset all items button -->
            <button class="icon-btn" 
                    @onclick="ConfirmResetAllItems" 
                    title="@AppResources.ResetAllItems">
                <i class="fa fa-undo-alt" aria-hidden="true"></i>
            </button>

            <!-- Edit mode button -->
            <button class="icon-btn" 
                    @onclick="SwitchToEditMode" 
                    title="@AppResources.EditActivity">
                <i class="fa fa-edit" aria-hidden="true"></i>
            </button>
        </div>
    </div>

    <div class="progress-container">
        <div class="progress-bar">
            <div class="progress-fill" style="width: @($"{GetCompletionPercentage()}%")"></div>
        </div>
        <div class="progress-stats">
            <span>@string.Format(AppResources.ItemsPacked, Items.Count(i => i.IsChecked), Items.Count)</span>
            <span class="time-remaining">@GetEstimatedTimeRemaining()</span>
        </div>
    </div>

    <main class="content-area @(_hideCheckedItems ? "hide-checked" : "")" @onkeydown="HandleKeyboardNavigation" tabindex="0" @ref="contentArea">
        @if (_isLoading)
        {
            <div class="loading">
                <div class="loading-spinner"></div>
                <span>@AppResources.LoadingPacking</span>
            </div>
        }
        else
        {
            @foreach (var category in _categoryOrder)
            {
                var groupItems = Items.Where(i => string.Equals(i.Item.Category, category, StringComparison.OrdinalIgnoreCase))
                                      .Where(i => !(_hideCheckedItems && i.IsChecked && !i.IsAnimating)) // Keep animating items visible
                                      .ToList();
                if (!groupItems.Any())
                    continue;

                var totalCount = Items.Where(i => string.Equals(i.Item.Category, category, StringComparison.OrdinalIgnoreCase)).Count();

                var allChecked = IsAllChecked(category);
                var collapsed = IsCollapsed(category);
                var categoryId = $"cat-{category}";

                <section class="category @(allChecked && !_hideCheckedItems ? "category-completed" : "")" aria-labelledby="@categoryId">
                    <div class="category-header" role="button" @onclick="() => ToggleCategory(category)" aria-expanded="@(!collapsed)">
                        <span class="chev @(collapsed ? "collapsed" : "")" aria-hidden="true">▾</span>
                        <h4 id="@categoryId" class="category-title @(allChecked && !_hideCheckedItems ? "checked" : "")">@category</h4>
                        <span class="count">@(_hideCheckedItems? totalCount - groupItems.Count() : groupItems.Count(x=>x.IsChecked))/@totalCount</span>
                    </div>

                    <ul class="category-content @(collapsed ? "hidden" : "")">
                        @foreach (var item in groupItems)
                        {
                            <li class="packing-row @(item.IsAnimating ? "vanishing" : "")" 
                                @key="item.Item.Id" 
                                @onclick="(e) => HandleRowClick(e, item)"
                                id="item-@item.Item.Id">
                                <div class="item-main">
                                    <div class="round-checkbox">
                                        <input id="@($"checkbox-{item.Item.Id}")" class="item-checkbox" type="checkbox" 
                                               checked="@item.IsChecked"
                                               @onchange="@(async (ChangeEventArgs e) => await HandleItemChecked(item, Convert.ToBoolean(e.Value), null))" 
                                               @onclick:stopPropagation="true" />
                                        <label for="@($"checkbox-{item.Item.Id}")" @onclick:stopPropagation="true"></label>
                                    </div>
                                    <span class="@($"item-text {(item.IsChecked ? "checked" : "")}")">
                                        @item.Item.Name
                                    </span>
                                </div>
                                

                                @if (!string.IsNullOrWhiteSpace(item.Item.Notes))
                                {
                                    <div class="notes">@item.Item.Notes</div>
                                }
                            </li>
                        }
                    </ul>
                </section>
            }
        }
    </main>
</div>

<div class="history-panel @(_showHistory ? "expanded" : "")">
    <div class="history-header" @onclick="ToggleHistory">
        <h4>@AppResources.PackingHistory</h4>
        <span class="chev @(_showHistory ? "" : "collapsed")">▾</span>
    </div>
    
    @if (_showHistory)
    {
        <div class="history-content">
            <div class="history-stats">
                <div class="stat-card">
                    <span class="stat-value">@_currentActivity.RunCount</span>
                    <span class="stat-label">@AppResources.TimesPacked</span>
                </div>
                <div class="stat-card">
                    <span class="stat-value">@(GetAveragePackingTime())</span>
                    <span class="stat-label">@AppResources.AvgTime</span>
                </div>
                <div class="stat-card">
                    <span class="stat-value">@(GetLastPackedDate())</span>
                    <span class="stat-label">@AppResources.LastPackedLabel</span>
                </div>
            </div>
            
            <div class="history-timeline">
                <h5>@AppResources.RecentActivity</h5>
                <ul class="timeline-list">
                    @foreach (var entry in GetRecentPackingHistory())
                    {
                        <li class="timeline-item">
                            <span class="timeline-date">@entry.Date.ToString("MMM d, HH:mm")</span>
                            <span class="timeline-action">@entry.Action</span>
                        </li>
                    }
                </ul>
            </div>
        </div>
    }
</div>

@if (GetCompletionPercentage() == 100 && !_completionAcknowledged)
{
    <div class="modal-overlay celebration">
        <div class="completion-modal">
            <div class="confetti-container">
                <!-- Confetti animation here -->
            </div>
            
            <h3>@AppResources.PackingComplete</h3>
            <p>@string.Format(AppResources.YouPackedItems, Items.Count, GetPackingDuration())</p>
            
            <div class="completion-stats">
                <div class="stat">
                    <span class="label">@AppResources.Efficiency</span>
                    <span class="value">@GetPackingEfficiency()</span>
                </div>
                <div class="stat">
                    <span class="label">@AppResources.ComparedToLastTime</span>
                    <span class="value @GetComparisonClass()">@GetComparisonText()</span>
                </div>
            </div>
            
            <button class="btn primary" @onclick="AcknowledgeCompletion">
                @AppResources.Great
            </button>
        </div>
    </div>
}

@code {
    [Parameter]
    public string Id { get; set; } = string.Empty;

    private const int PackedItemAnimationDelayMs = 350;

    private bool _isLoading;
    private DateTime _packingStartTime;
    private bool _showHistory = false;
    private bool _completionAcknowledged = false;
    private bool _hideCheckedItems = true;

    private Storage.PackingActivity _currentActivity = new Storage.PackingActivity();

    private sealed class PackingItemView
    {
        public PackingItemView(Storage.PackingItem item) => Item = item;
        public Storage.PackingItem Item { get; }
        public bool IsChecked { get; set; }
        public bool IsAnimating { get; set; } // Track animation state
    }

    private ElementReference contentArea;
    private int _currentFocusIndex = -1;

    private List<PackingItemView> Items { get; set; } = new();
    private List<string> _categoryOrder = new();
    private readonly Dictionary<string, bool?> _manualOverride = new(StringComparer.OrdinalIgnoreCase);

    protected override async Task OnInitializedAsync()
    {
        _packingStartTime = DateTime.Now;

        if (!string.IsNullOrEmpty(Id))
        {
            await LoadItemsForPackingAsync(Id);
        }

        await base.OnInitializedAsync();
    }

    private async Task LoadItemsForPackingAsync(string id)
    {
        _isLoading = true;
        StateHasChanged();

        try
        {
            _currentActivity = await PackingRepository.GetByIdAsync(id) ?? new Storage.PackingActivity(){ Name = AppResources.PackingActivity };
            SidebarTextService.SetPackingId(_currentActivity.Id);
            SidebarTextService.SetText(_currentActivity.Name ?? "");
            var itemsFromRepo = await PackingRepository.GetItemsForActivityAsync(id);

            // Map items from repository and restore their packed state
            Items = itemsFromRepo.Select(pi => new PackingItemView(pi) 
            { 
                IsChecked = pi.IsPacked  // Restore the packed state from database
            }).ToList();

            _categoryOrder = Items.Select(i => i.Item.Category).Distinct(StringComparer.OrdinalIgnoreCase).ToList();

            if (!_categoryOrder.Any())
            {
                _categoryOrder.Add(PackingCategory.Miscellaneous.ToString());
            }

            _manualOverride.Clear();
            foreach (var cat in _categoryOrder)
            {
                // If all items in category are checked, collapse it
                var allChecked = IsAllChecked(cat);
                _manualOverride[cat] = allChecked ? true : false;
            }
        }
        catch
        {
            ToastService.ShowError(AppResources.FailedToLoadItems);
        }
        finally
        {
            _isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ToggleCategory(string category)
    {
        var currentlyCollapsed = IsCollapsed(category);
        _manualOverride[category] = !currentlyCollapsed;
    }

    private void SetItemChecked(PackingItemView item, bool isChecked)
    {
        item.IsChecked = isChecked;
        UpdateCategoryStateAfterItemChange(item.Item.Category);
        SaveCheckState(item);
    }

    private void ToggleItemChecked(PackingItemView item)
    {
        item.IsChecked = !item.IsChecked;
        UpdateCategoryStateAfterItemChange(item.Item.Category);
        SaveCheckState(item);
    }

    private async void SaveCheckState(PackingItemView item)
    {
        if (!string.IsNullOrEmpty(Id))
        {
            try
            {
                item.Item.IsPacked = item.IsChecked;
                await PackingRepository.AddOrUpdateItemAsync(item.Item);
            }
            catch (Exception ex)
            {
                ToastService.ShowError(string.Format(AppResources.ErrorSavingItemState, ex.Message));
            }
        }
    }

    private void UpdateCategoryStateAfterItemChange(string category)
    {
        var allChecked = IsAllChecked(category);

        if (allChecked)
            _manualOverride[category] = true; // Auto-collapse category when all its items are packed

        StateHasChanged();

        if (GetCompletionPercentage() == 100 && !_completionAcknowledged)
        {
            StateHasChanged(); // Trigger completion modal
        }
    }

    private bool IsAllChecked(string category)
    {
        var group = Items.Where(i => string.Equals(i.Item.Category, category, StringComparison.OrdinalIgnoreCase));
        return group.Any() && group.All(i => i.IsChecked);
    }

    private bool IsCollapsed(string category)
    {
        if (_manualOverride.TryGetValue(category, out var manual) && manual.HasValue)
            return manual.Value;

        return IsAllChecked(category);
    }

    private void HandleKeyboardNavigation(KeyboardEventArgs e)
    {
        var itemsList = Items.ToList();

        switch (e.Key)
        {
            case "ArrowDown":
                _currentFocusIndex = Math.Min(_currentFocusIndex + 1, itemsList.Count - 1);
                break;
            case "ArrowUp":
                _currentFocusIndex = Math.Max(_currentFocusIndex - 1, 0);
                break;
            case " ": // Space key
                if (_currentFocusIndex >= 0 && _currentFocusIndex < itemsList.Count)
                    ToggleItemChecked(itemsList[_currentFocusIndex]);
                break;
        }

        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            await JSRuntime.InvokeVoidAsync("focusElement", contentArea);
        }
    }

    private void ToggleHistory()
    {
        _showHistory = !_showHistory;
    }

    private int GetCompletionPercentage() => 
        Items.Any() ? (int)(Items.Count(i => i.IsChecked) * 100.0 / Items.Count) : 0;

    private string GetEstimatedTimeRemaining()
    {
        var itemsLeft = Items.Count(i => !i.IsChecked);
        // Estimate 30 seconds per remaining item
        var minutesLeft = Math.Ceiling(itemsLeft * 0.5);
        return minutesLeft > 0 ? string.Format(AppResources.MinRemaining, minutesLeft) : AppResources.Done;
    }

    private string GetAveragePackingTime() => "15 min";

    private string GetLastPackedDate() => _currentActivity.LastPacked.ToString("MMM d");

    private class HistoryEntry
    {
        public DateTime Date = DateTime.Now;
        public string Action { get; set; } = "Packed items";
    }

    // This would be replaced with actual history data from storage
    private List<HistoryEntry> GetRecentPackingHistory() => new()
    {
        new HistoryEntry { Date = DateTime.Now.AddDays(-5), Action = "Packed 15 items in 12 minutes" },
        new HistoryEntry { Date = DateTime.Now.AddDays(-12), Action = "Packed 18 items in 15 minutes" }
    };

    private string GetPackingDuration()
    {
        var duration = DateTime.Now - _packingStartTime;
        return $"{(int)duration.TotalMinutes} minutes";
    }

    private string GetPackingEfficiency() => "95%"; // Placeholder
    private string GetComparisonClass() => "better"; // Placeholder
    private string GetComparisonText() => "2 minutes faster"; // Placeholder

    private async Task AcknowledgeCompletion()
    {
        _completionAcknowledged = true;
        // Record completion
        _currentActivity.LastPacked = DateTime.Now;
        _currentActivity.RunCount++;

        // Save to repository
        if (!string.IsNullOrWhiteSpace(Id))
        {
            await PackingRepository.AddOrUpdateAsync(_currentActivity);
        }
    }

    private async Task SwitchToEditMode()
    {
        if(Items.Count(i => i.IsChecked) > 0)
        {
            bool confirm = await DialogService.ShowConfirmAsync(
                AppResources.SwitchToEditMode, 
                AppResources.EditingMightAffectProgress, 
                AppResources.ContinueToEdit, 
                AppResources.Cancel);

            if (confirm)
            {
                NavigateToEditMode();
            }
        }
        else
        {
            NavigateToEditMode();
        }
    }

    private void NavigateToEditMode()
    {
        if (!string.IsNullOrEmpty(Id))
        {
            Navigation.NavigateTo($"/edit-packing/{Id}");
        }
    }

    public void Dispose()
    {
        // No toast cleanup needed anymore
    }

    private void ToggleItemVisibility()
    {
        _hideCheckedItems = !_hideCheckedItems;
    }

    private async Task ConfirmResetAllItems()
    {
        bool confirm = await DialogService.ShowConfirmAsync(
            AppResources.ResetPackingList, 
            AppResources.ConfirmResetAllItems, 
            AppResources.ResetAll, 
            AppResources.Cancel);

        if (confirm)
        {
            await ResetAllItems();
            ExpandAllCategories();
        }
    }

    private void ExpandAllCategories()
    {
        foreach (var key in _manualOverride.Keys)
        {
            _manualOverride[key] = false; // false it is expanded
        }
    }

    private async Task ResetAllItems()
    {
        // Count how many items were checked before reset
        int checkedItemsCount = Items.Count(i => i.IsChecked);
        
        foreach (var item in Items)
        {
            item.IsChecked = false;
            item.Item.IsPacked = false;
        }
        
        // Save to repository
        if (!string.IsNullOrEmpty(Id))
        {
            try
            {
                foreach (var item in Items)
                {
                    await PackingRepository.AddOrUpdateItemAsync(item.Item);
                }
                
                // Show a toast with the result
                ToastService.ShowInfo(string.Format(AppResources.ResetItemsSuccess, checkedItemsCount));
                
                // Refresh categories state
                foreach (var category in _categoryOrder)
                {
                    UpdateCategoryStateAfterItemChange(category);
                }
                
                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                ToastService.ShowError(string.Format(AppResources.ErrorResettingItems, ex.Message));
            }
        }
    }

    private async Task HandleRowClick(MouseEventArgs e, PackingItemView item)
    {
        await HandleItemChecked(item, !item.IsChecked, e);
    }

    private async Task HandleItemChecked(PackingItemView item, bool isChecked, MouseEventArgs? e)
    {
        // Only apply animation when marking as checked (not unchecking)
        if (!item.IsChecked && isChecked)
        {
            try
            {
                item.IsAnimating = true;
                StateHasChanged(); // Force UI update to show animation starting
                
                item.IsChecked = isChecked;
                await Task.Delay(PackedItemAnimationDelayMs);
                
                UpdateCategoryStateAfterItemChange(item.Item.Category);
                                
                // Save the change to repository
                SaveCheckState(item);
            }
            catch (Exception ex)
            {
                // Fallback if animation fails
                item.IsChecked = isChecked;
                UpdateCategoryStateAfterItemChange(item.Item.Category);
                SaveCheckState(item);
                ToastService.ShowSuccess(string.Format(AppResources.ItemPacked, item.Item.Name));
            }
            finally
            {
                // End animation state
                item.IsAnimating = false;
                
                // Force UI update if needed
                if (_hideCheckedItems)
                {
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        else
        {
            // For unchecking, just update without animation
            item.IsChecked = isChecked;
            
            if (isChecked)
            {
                ToastService.ShowSuccess(string.Format(AppResources.ItemPacked, item.Item.Name));
            }
            else
            {
                ToastService.ShowInfo(string.Format(AppResources.ItemUnpacked, item.Item.Name));
            }
            
            UpdateCategoryStateAfterItemChange(item.Item.Category);
            SaveCheckState(item);
            
            if (_hideCheckedItems)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
    }
}